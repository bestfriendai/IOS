//
//  PictureInPictureManager.swift
//  StreamyyyApp
//
//  Implements Picture-in-Picture mode for individual streams
//

import Foundation
import SwiftUI
import AVKit
import Combine

@MainActor
public class PictureInPictureManager: ObservableObject {
    // MARK: - Published Properties
    @Published public var isActive: Bool = false
    @Published public var currentStream: Stream?
    @Published public var position: PiPPosition = .bottomTrailing
    @Published public var size: PiPSize = .medium
    @Published public var isDragging: Bool = false
    @Published public var isExpanded: Bool = false
    @Published public var showingControls: Bool = false
    @Published public var opacity: Double = 1.0
    
    // MARK: - Private Properties
    private var pipController: AVPictureInPictureController?
    private var cancellables = Set<AnyCancellable>()
    private var dragOffset: CGSize = .zero\n    private var lastPosition: CGPoint = .zero\n    private var controlsTimer: Timer?\n    private let audioManager: AudioManager\n    private let layoutManager: MultiStreamLayoutManager\n    \n    // MARK: - Configuration\n    private let minSize = CGSize(width: 120, height: 68)\n    private let maxSize = CGSize(width: 320, height: 180)\n    private let edgeMargin: CGFloat = 20\n    private let snapDistance: CGFloat = 50\n    private let autoHideDelay: TimeInterval = 3.0\n    private let expandedScale: CGFloat = 1.5\n    \n    // MARK: - Initialization\n    public init(audioManager: AudioManager, layoutManager: MultiStreamLayoutManager) {\n        self.audioManager = audioManager\n        self.layoutManager = layoutManager\n        setupBindings()\n    }\n    \n    // MARK: - Public Methods\n    \n    /// Enter Picture-in-Picture mode with a stream\n    public func enterPictureInPicture(with stream: Stream) {\n        guard !isActive else { return }\n        \n        currentStream = stream\n        isActive = true\n        \n        // Ensure PiP stream has audio\n        audioManager.enterPictureInPicture(stream)\n        \n        // Calculate initial position\n        calculateInitialPosition()\n        \n        // Show controls temporarily\n        showControls()\n        \n        // Haptic feedback\n        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)\n        impactFeedback.impactOccurred()\n    }\n    \n    /// Exit Picture-in-Picture mode\n    public func exitPictureInPicture() {\n        guard isActive else { return }\n        \n        isActive = false\n        currentStream = nil\n        isExpanded = false\n        showingControls = false\n        \n        // Notify audio manager\n        audioManager.exitPictureInPicture()\n        \n        // Clean up\n        controlsTimer?.invalidate()\n        controlsTimer = nil\n        \n        // Haptic feedback\n        let impactFeedback = UIImpactFeedbackGenerator(style: .light)\n        impactFeedback.impactOccurred()\n    }\n    \n    /// Toggle expanded state\n    public func toggleExpanded() {\n        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {\n            isExpanded.toggle()\n        }\n        \n        if isExpanded {\n            showControls()\n        }\n    }\n    \n    /// Change PiP position\n    public func changePosition(to newPosition: PiPPosition) {\n        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {\n            position = newPosition\n        }\n    }\n    \n    /// Change PiP size\n    public func changeSize(to newSize: PiPSize) {\n        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {\n            size = newSize\n        }\n    }\n    \n    /// Handle drag gesture\n    public func handleDrag(translation: CGSize) {\n        isDragging = true\n        dragOffset = translation\n        \n        // Show controls while dragging\n        showControls()\n    }\n    \n    /// Handle drag end\n    public func handleDragEnd(translation: CGSize, predictedEndTranslation: CGSize) {\n        isDragging = false\n        dragOffset = .zero\n        \n        // Snap to nearest edge\n        snapToNearestEdge(translation: translation, predictedEnd: predictedEndTranslation)\n        \n        // Hide controls after delay\n        scheduleControlsHide()\n    }\n    \n    /// Handle tap gesture\n    public func handleTap() {\n        if showingControls {\n            // Hide controls on tap\n            hideControls()\n        } else {\n            // Show controls on tap\n            showControls()\n        }\n    }\n    \n    /// Handle double tap\n    public func handleDoubleTap() {\n        if isExpanded {\n            // Exit to full screen\n            exitPictureInPictureToFullscreen()\n        } else {\n            // Expand PiP\n            toggleExpanded()\n        }\n    }\n    \n    /// Handle long press\n    public func handleLongPress() {\n        // Show context menu\n        showContextMenu()\n    }\n    \n    /// Get current PiP frame\n    public func getCurrentFrame(in containerSize: CGSize) -> CGRect {\n        let pipSize = getCurrentSize()\n        let pipPosition = getCurrentPosition(in: containerSize, pipSize: pipSize)\n        \n        return CGRect(\n            x: pipPosition.x + dragOffset.width,\n            y: pipPosition.y + dragOffset.height,\n            width: pipSize.width,\n            height: pipSize.height\n        )\n    }\n    \n    /// Check if PiP is visible\n    public func isVisible() -> Bool {\n        return isActive && opacity > 0\n    }\n    \n    /// Set PiP opacity\n    public func setOpacity(_ newOpacity: Double) {\n        withAnimation(.easeInOut(duration: 0.2)) {\n            opacity = max(0.1, min(1.0, newOpacity))\n        }\n    }\n    \n    // MARK: - Private Methods\n    \n    private func setupBindings() {\n        // Hide controls when not showing\n        $showingControls\n            .sink { [weak self] showing in\n                if showing {\n                    self?.scheduleControlsHide()\n                }\n            }\n            .store(in: &cancellables)\n        \n        // Reset expanded state when exiting PiP\n        $isActive\n            .sink { [weak self] active in\n                if !active {\n                    self?.isExpanded = false\n                }\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func calculateInitialPosition() {\n        // Start at bottom trailing by default\n        position = .bottomTrailing\n    }\n    \n    private func getCurrentSize() -> CGSize {\n        let baseSize: CGSize\n        \n        switch size {\n        case .small:\n            baseSize = CGSize(width: 120, height: 68)\n        case .medium:\n            baseSize = CGSize(width: 180, height: 101)\n        case .large:\n            baseSize = CGSize(width: 240, height: 135)\n        }\n        \n        if isExpanded {\n            return CGSize(\n                width: baseSize.width * expandedScale,\n                height: baseSize.height * expandedScale\n            )\n        }\n        \n        return baseSize\n    }\n    \n    private func getCurrentPosition(in containerSize: CGSize, pipSize: CGSize) -> CGPoint {\n        let margin = edgeMargin\n        \n        switch position {\n        case .topLeading:\n            return CGPoint(x: margin, y: margin)\n        case .topTrailing:\n            return CGPoint(x: containerSize.width - pipSize.width - margin, y: margin)\n        case .bottomLeading:\n            return CGPoint(x: margin, y: containerSize.height - pipSize.height - margin)\n        case .bottomTrailing:\n            return CGPoint(x: containerSize.width - pipSize.width - margin, y: containerSize.height - pipSize.height - margin)\n        case .center:\n            return CGPoint(\n                x: (containerSize.width - pipSize.width) / 2,\n                y: (containerSize.height - pipSize.height) / 2\n            )\n        case .custom(let point):\n            return point\n        }\n    }\n    \n    private func snapToNearestEdge(translation: CGSize, predictedEnd: CGSize) {\n        // Determine which edge is closest\n        let currentFrame = getCurrentFrame(in: layoutManager.containerSize)\n        let containerSize = layoutManager.containerSize\n        \n        let centerX = currentFrame.midX\n        let centerY = currentFrame.midY\n        \n        let distanceToLeft = centerX\n        let distanceToRight = containerSize.width - centerX\n        let distanceToTop = centerY\n        let distanceToBottom = containerSize.height - centerY\n        \n        let minDistance = min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom)\n        \n        let newPosition: PiPPosition\n        \n        if minDistance == distanceToLeft {\n            newPosition = centerY < containerSize.height / 2 ? .topLeading : .bottomLeading\n        } else if minDistance == distanceToRight {\n            newPosition = centerY < containerSize.height / 2 ? .topTrailing : .bottomTrailing\n        } else if minDistance == distanceToTop {\n            newPosition = centerX < containerSize.width / 2 ? .topLeading : .topTrailing\n        } else {\n            newPosition = centerX < containerSize.width / 2 ? .bottomLeading : .bottomTrailing\n        }\n        \n        changePosition(to: newPosition)\n    }\n    \n    private func showControls() {\n        withAnimation(.easeInOut(duration: 0.2)) {\n            showingControls = true\n        }\n    }\n    \n    private func hideControls() {\n        withAnimation(.easeInOut(duration: 0.2)) {\n            showingControls = false\n        }\n    }\n    \n    private func scheduleControlsHide() {\n        controlsTimer?.invalidate()\n        controlsTimer = Timer.scheduledTimer(withTimeInterval: autoHideDelay, repeats: false) { [weak self] _ in\n            self?.hideControls()\n        }\n    }\n    \n    private func exitPictureInPictureToFullscreen() {\n        guard let stream = currentStream else { return }\n        \n        // Exit PiP\n        exitPictureInPicture()\n        \n        // Enter fullscreen\n        layoutManager.enterFullscreen(stream)\n    }\n    \n    private func showContextMenu() {\n        // Show context menu with options\n        // Implementation depends on the UI framework\n    }\n}\n\n// MARK: - PiP Position\npublic enum PiPPosition: Equatable {\n    case topLeading\n    case topTrailing\n    case bottomLeading\n    case bottomTrailing\n    case center\n    case custom(CGPoint)\n    \n    public var displayName: String {\n        switch self {\n        case .topLeading: return \"Top Left\"\n        case .topTrailing: return \"Top Right\"\n        case .bottomLeading: return \"Bottom Left\"\n        case .bottomTrailing: return \"Bottom Right\"\n        case .center: return \"Center\"\n        case .custom: return \"Custom\"\n        }\n    }\n}\n\n// MARK: - PiP Size\npublic enum PiPSize: String, CaseIterable {\n    case small = \"small\"\n    case medium = \"medium\"\n    case large = \"large\"\n    \n    public var displayName: String {\n        switch self {\n        case .small: return \"Small\"\n        case .medium: return \"Medium\"\n        case .large: return \"Large\"\n        }\n    }\n    \n    public var scale: CGFloat {\n        switch self {\n        case .small: return 0.8\n        case .medium: return 1.0\n        case .large: return 1.2\n        }\n    }\n}\n\n// MARK: - Picture-in-Picture View\npublic struct PictureInPictureView: View {\n    @ObservedObject private var pipManager: PictureInPictureManager\n    let containerSize: CGSize\n    \n    public init(pipManager: PictureInPictureManager, containerSize: CGSize) {\n        self.pipManager = pipManager\n        self.containerSize = containerSize\n    }\n    \n    public var body: some View {\n        Group {\n            if pipManager.isActive, let stream = pipManager.currentStream {\n                pipView(for: stream)\n            }\n        }\n    }\n    \n    private func pipView(for stream: Stream) -> some View {\n        let frame = pipManager.getCurrentFrame(in: containerSize)\n        \n        return ZStack {\n            // Stream content\n            StreamWebView(\n                url: stream.url,\n                isMuted: false,\n                isLoading: .constant(false),\n                hasError: .constant(false)\n            )\n            .clipShape(RoundedRectangle(cornerRadius: 12))\n            \n            // Controls overlay\n            if pipManager.showingControls {\n                pipControlsOverlay(for: stream)\n            }\n            \n            // Border\n            RoundedRectangle(cornerRadius: 12)\n                .stroke(Color.white.opacity(0.3), lineWidth: 1)\n        }\n        .frame(width: frame.width, height: frame.height)\n        .position(x: frame.midX, y: frame.midY)\n        .opacity(pipManager.opacity)\n        .scaleEffect(pipManager.isDragging ? 1.05 : 1.0)\n        .shadow(radius: 8)\n        .animation(.spring(response: 0.3), value: pipManager.isDragging)\n        .animation(.spring(response: 0.4), value: pipManager.isExpanded)\n        .gesture(\n            DragGesture()\n                .onChanged { value in\n                    pipManager.handleDrag(translation: value.translation)\n                }\n                .onEnded { value in\n                    pipManager.handleDragEnd(\n                        translation: value.translation,\n                        predictedEndTranslation: value.predictedEndTranslation\n                    )\n                }\n        )\n        .onTapGesture {\n            pipManager.handleTap()\n        }\n        .onTapGesture(count: 2) {\n            pipManager.handleDoubleTap()\n        }\n        .onLongPressGesture {\n            pipManager.handleLongPress()\n        }\n    }\n    \n    private func pipControlsOverlay(for stream: Stream) -> some View {\n        VStack {\n            // Top controls\n            HStack {\n                Button(action: {\n                    pipManager.exitPictureInPicture()\n                }) {\n                    Image(systemName: \"xmark\")\n                        .font(.caption)\n                        .foregroundColor(.white)\n                        .frame(width: 24, height: 24)\n                        .background(Color.black.opacity(0.6))\n                        .clipShape(Circle())\n                }\n                \n                Spacer()\n                \n                Button(action: {\n                    pipManager.toggleExpanded()\n                }) {\n                    Image(systemName: pipManager.isExpanded ? \"arrow.down.right.and.arrow.up.left\" : \"arrow.up.left.and.arrow.down.right\")\n                        .font(.caption)\n                        .foregroundColor(.white)\n                        .frame(width: 24, height: 24)\n                        .background(Color.black.opacity(0.6))\n                        .clipShape(Circle())\n                }\n            }\n            .padding(8)\n            \n            Spacer()\n            \n            // Bottom info\n            if pipManager.isExpanded {\n                VStack(alignment: .leading, spacing: 4) {\n                    Text(stream.displayTitle)\n                        .font(.caption2)\n                        .foregroundColor(.white)\n                        .lineLimit(2)\n                    \n                    if let streamerName = stream.streamerName {\n                        Text(streamerName)\n                            .font(.caption2)\n                            .foregroundColor(.white.opacity(0.8))\n                            .lineLimit(1)\n                    }\n                }\n                .padding(8)\n                .background(Color.black.opacity(0.4))\n                .clipShape(RoundedRectangle(cornerRadius: 8))\n                .padding(8)\n            }\n        }\n        .transition(.opacity)\n    }\n}\n\n// MARK: - Extensions\nextension PictureInPictureManager {\n    \n    /// Get available positions for PiP\n    public func getAvailablePositions() -> [PiPPosition] {\n        return [.topLeading, .topTrailing, .bottomLeading, .bottomTrailing, .center]\n    }\n    \n    /// Get available sizes for PiP\n    public func getAvailableSizes() -> [PiPSize] {\n        return PiPSize.allCases\n    }\n    \n    /// Check if PiP can be activated\n    public func canActivatePictureInPicture() -> Bool {\n        return !isActive && currentStream != nil\n    }\n    \n    /// Get PiP configuration\n    public func getConfiguration() -> PiPConfiguration {\n        return PiPConfiguration(\n            position: position,\n            size: size,\n            opacity: opacity,\n            autoHide: true,\n            snapToEdges: true\n        )\n    }\n    \n    /// Update PiP configuration\n    public func updateConfiguration(_ config: PiPConfiguration) {\n        position = config.position\n        size = config.size\n        setOpacity(config.opacity)\n    }\n}\n\n// MARK: - PiP Configuration\npublic struct PiPConfiguration {\n    public let position: PiPPosition\n    public let size: PiPSize\n    public let opacity: Double\n    public let autoHide: Bool\n    public let snapToEdges: Bool\n    \n    public init(\n        position: PiPPosition = .bottomTrailing,\n        size: PiPSize = .medium,\n        opacity: Double = 1.0,\n        autoHide: Bool = true,\n        snapToEdges: Bool = true\n    ) {\n        self.position = position\n        self.size = size\n        self.opacity = opacity\n        self.autoHide = autoHide\n        self.snapToEdges = snapToEdges\n    }\n}"}