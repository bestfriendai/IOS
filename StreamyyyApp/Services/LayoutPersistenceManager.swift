//
//  LayoutPersistenceManager.swift
//  StreamyyyApp
//
//  Add layout persistence and user preferences storage
//

import Foundation
import SwiftUI
import SwiftData
import Combine

@MainActor
public class LayoutPersistenceManager: ObservableObject {
    // MARK: - Published Properties
    @Published public var savedLayouts: [Layout] = []
    @Published public var userPreferences: UserLayoutPreferences = UserLayoutPreferences()
    @Published public var recentLayouts: [Layout] = []
    @Published public var favoriteLayouts: [Layout] = []
    @Published public var isLoading: Bool = false
    @Published public var lastError: Error?
    
    // MARK: - Private Properties
    private var modelContext: ModelContext?
    private var cancellables = Set<AnyCancellable>()
    private let userDefaults = UserDefaults.standard
    private let fileManager = FileManager.default
    private let documentsDirectory: URL
    
    // MARK: - Configuration
    private let maxRecentLayouts = 10
    private let maxFavoriteLayouts = 50
    private let autoSaveInterval: TimeInterval = 30.0
    private var autoSaveTimer: Timer?
    
    // MARK: - Initialization
    public init() {
        documentsDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
        setupAutoSave()
        loadUserPreferences()
    }
    
    // MARK: - Setup Methods
    public func setModelContext(_ modelContext: ModelContext) {
        self.modelContext = modelContext
        loadSavedLayouts()
    }
    
    // MARK: - Layout Management
    
    /// Save a layout to persistence
    public func saveLayout(_ layout: Layout) {
        guard let modelContext = modelContext else { return }
        
        do {
            // Add to SwiftData
            modelContext.insert(layout)
            try modelContext.save()
            
            // Update local arrays
            if !savedLayouts.contains(where: { $0.id == layout.id }) {
                savedLayouts.append(layout)\n            }\n            \n            // Add to recent layouts\n            addToRecentLayouts(layout)\n            \n            // Save preferences\n            saveUserPreferences()\n            \n        } catch {\n            lastError = LayoutPersistenceError.saveFailed(error)\n        }\n    }\n    \n    /// Load all saved layouts\n    public func loadSavedLayouts() {\n        guard let modelContext = modelContext else { return }\n        \n        isLoading = true\n        \n        do {\n            let descriptor = FetchDescriptor<Layout>(sortBy: [SortDescriptor(\\Layout.updatedAt, order: .reverse)])\n            savedLayouts = try modelContext.fetch(descriptor)\n            \n            // Update recent and favorite layouts\n            updateRecentLayouts()\n            updateFavoriteLayouts()\n            \n        } catch {\n            lastError = LayoutPersistenceError.loadFailed(error)\n        }\n        \n        isLoading = false\n    }\n    \n    /// Delete a layout\n    public func deleteLayout(_ layout: Layout) {\n        guard let modelContext = modelContext else { return }\n        \n        do {\n            modelContext.delete(layout)\n            try modelContext.save()\n            \n            // Remove from local arrays\n            savedLayouts.removeAll { $0.id == layout.id }\n            recentLayouts.removeAll { $0.id == layout.id }\n            favoriteLayouts.removeAll { $0.id == layout.id }\n            \n            // Update preferences\n            userPreferences.favoriteLayoutIds.removeAll { $0 == layout.id }\n            saveUserPreferences()\n            \n        } catch {\n            lastError = LayoutPersistenceError.deleteFailed(error)\n        }\n    }\n    \n    /// Update an existing layout\n    public func updateLayout(_ layout: Layout) {\n        guard let modelContext = modelContext else { return }\n        \n        do {\n            layout.updatedAt = Date()\n            try modelContext.save()\n            \n            // Update local arrays\n            if let index = savedLayouts.firstIndex(where: { $0.id == layout.id }) {\n                savedLayouts[index] = layout\n            }\n            \n            // Add to recent layouts\n            addToRecentLayouts(layout)\n            \n        } catch {\n            lastError = LayoutPersistenceError.updateFailed(error)\n        }\n    }\n    \n    /// Get layout by ID\n    public func getLayout(by id: String) -> Layout? {\n        return savedLayouts.first { $0.id == id }\n    }\n    \n    /// Duplicate a layout\n    public func duplicateLayout(_ layout: Layout) -> Layout {\n        let duplicatedLayout = Layout(\n            name: \"\\(layout.name) Copy\",\n            type: layout.type,\n            configuration: layout.configuration\n        )\n        \n        duplicatedLayout.description = layout.description\n        duplicatedLayout.tags = layout.tags\n        duplicatedLayout.isCustom = true\n        \n        saveLayout(duplicatedLayout)\n        \n        return duplicatedLayout\n    }\n    \n    // MARK: - Recent Layouts\n    \n    /// Add layout to recent layouts\n    public func addToRecentLayouts(_ layout: Layout) {\n        // Remove if already exists\n        recentLayouts.removeAll { $0.id == layout.id }\n        \n        // Add to beginning\n        recentLayouts.insert(layout, at: 0)\n        \n        // Limit to max recent layouts\n        if recentLayouts.count > maxRecentLayouts {\n            recentLayouts = Array(recentLayouts.prefix(maxRecentLayouts))\n        }\n        \n        // Save to user preferences\n        userPreferences.recentLayoutIds = recentLayouts.map { $0.id }\n        saveUserPreferences()\n    }\n    \n    /// Clear recent layouts\n    public func clearRecentLayouts() {\n        recentLayouts.removeAll()\n        userPreferences.recentLayoutIds.removeAll()\n        saveUserPreferences()\n    }\n    \n    // MARK: - Favorite Layouts\n    \n    /// Add layout to favorites\n    public func addToFavorites(_ layout: Layout) {\n        guard !favoriteLayouts.contains(where: { $0.id == layout.id }) else { return }\n        guard favoriteLayouts.count < maxFavoriteLayouts else { return }\n        \n        favoriteLayouts.append(layout)\n        userPreferences.favoriteLayoutIds.append(layout.id)\n        saveUserPreferences()\n    }\n    \n    /// Remove layout from favorites\n    public func removeFromFavorites(_ layout: Layout) {\n        favoriteLayouts.removeAll { $0.id == layout.id }\n        userPreferences.favoriteLayoutIds.removeAll { $0 == layout.id }\n        saveUserPreferences()\n    }\n    \n    /// Check if layout is favorite\n    public func isFavorite(_ layout: Layout) -> Bool {\n        return favoriteLayouts.contains(where: { $0.id == layout.id })\n    }\n    \n    /// Toggle favorite status\n    public func toggleFavorite(_ layout: Layout) {\n        if isFavorite(layout) {\n            removeFromFavorites(layout)\n        } else {\n            addToFavorites(layout)\n        }\n    }\n    \n    // MARK: - User Preferences\n    \n    /// Save user preferences\n    public func saveUserPreferences() {\n        do {\n            let data = try JSONEncoder().encode(userPreferences)\n            userDefaults.set(data, forKey: \"UserLayoutPreferences\")\n        } catch {\n            lastError = LayoutPersistenceError.preferencesError(error)\n        }\n    }\n    \n    /// Load user preferences\n    public func loadUserPreferences() {\n        guard let data = userDefaults.data(forKey: \"UserLayoutPreferences\") else {\n            userPreferences = UserLayoutPreferences()\n            return\n        }\n        \n        do {\n            userPreferences = try JSONDecoder().decode(UserLayoutPreferences.self, from: data)\n        } catch {\n            lastError = LayoutPersistenceError.preferencesError(error)\n            userPreferences = UserLayoutPreferences()\n        }\n    }\n    \n    /// Update user preferences\n    public func updateUserPreferences(_ preferences: UserLayoutPreferences) {\n        userPreferences = preferences\n        saveUserPreferences()\n    }\n    \n    // MARK: - Import/Export\n    \n    /// Export layout to file\n    public func exportLayout(_ layout: Layout) -> URL? {\n        do {\n            let exportData = layout.exportConfiguration()\n            let jsonData = try JSONSerialization.data(withJSONObject: exportData, options: .prettyPrinted)\n            \n            let fileName = \"\\(layout.name.replacingOccurrences(of: \" \", with: \"_\")).json\"\n            let fileURL = documentsDirectory.appendingPathComponent(fileName)\n            \n            try jsonData.write(to: fileURL)\n            \n            return fileURL\n        } catch {\n            lastError = LayoutPersistenceError.exportFailed(error)\n            return nil\n        }\n    }\n    \n    /// Import layout from file\n    public func importLayout(from url: URL) -> Layout? {\n        do {\n            let data = try Data(contentsOf: url)\n            let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]\n            \n            guard let json = json,\n                  let layout = Layout.importConfiguration(json) else {\n                lastError = LayoutPersistenceError.importFailed(NSError(domain: \"LayoutImport\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Invalid layout file\"]))\n                return nil\n            }\n            \n            // Make it custom and save\n            layout.isCustom = true\n            saveLayout(layout)\n            \n            return layout\n        } catch {\n            lastError = LayoutPersistenceError.importFailed(error)\n            return nil\n        }\n    }\n    \n    /// Export all layouts\n    public func exportAllLayouts() -> URL? {\n        do {\n            let allLayoutsData = savedLayouts.map { $0.exportConfiguration() }\n            let jsonData = try JSONSerialization.data(withJSONObject: allLayoutsData, options: .prettyPrinted)\n            \n            let fileName = \"StreamyyyLayouts_\\(Date().formatted(date: .abbreviated, time: .omitted)).json\"\n            let fileURL = documentsDirectory.appendingPathComponent(fileName)\n            \n            try jsonData.write(to: fileURL)\n            \n            return fileURL\n        } catch {\n            lastError = LayoutPersistenceError.exportFailed(error)\n            return nil\n        }\n    }\n    \n    /// Import multiple layouts from file\n    public func importLayouts(from url: URL) -> [Layout] {\n        do {\n            let data = try Data(contentsOf: url)\n            let json = try JSONSerialization.jsonObject(with: data, options: []) as? [[String: Any]]\n            \n            guard let json = json else {\n                lastError = LayoutPersistenceError.importFailed(NSError(domain: \"LayoutImport\", code: 0, userInfo: [NSLocalizedDescriptionKey: \"Invalid layouts file\"]))\n                return []\n            }\n            \n            var importedLayouts: [Layout] = []\n            \n            for layoutData in json {\n                if let layout = Layout.importConfiguration(layoutData) {\n                    layout.isCustom = true\n                    saveLayout(layout)\n                    importedLayouts.append(layout)\n                }\n            }\n            \n            return importedLayouts\n        } catch {\n            lastError = LayoutPersistenceError.importFailed(error)\n            return []\n        }\n    }\n    \n    // MARK: - Search and Filter\n    \n    /// Search layouts by name or description\n    public func searchLayouts(query: String) -> [Layout] {\n        guard !query.isEmpty else { return savedLayouts }\n        \n        return savedLayouts.filter { layout in\n            layout.name.localizedCaseInsensitiveContains(query) ||\n            layout.description?.localizedCaseInsensitiveContains(query) == true ||\n            layout.tags.contains { $0.localizedCaseInsensitiveContains(query) }\n        }\n    }\n    \n    /// Filter layouts by type\n    public func filterLayouts(by type: LayoutType) -> [Layout] {\n        return savedLayouts.filter { $0.type == type }\n    }\n    \n    /// Filter layouts by tags\n    public func filterLayouts(by tags: [String]) -> [Layout] {\n        return savedLayouts.filter { layout in\n            tags.allSatisfy { tag in\n                layout.tags.contains { $0.localizedCaseInsensitiveContains(tag) }\n            }\n        }\n    }\n    \n    /// Get layouts by category\n    public func getLayoutsByCategory(_ category: LayoutCategory) -> [Layout] {\n        return LayoutPresets.getLayoutsByCategory(category)\n    }\n    \n    // MARK: - Statistics\n    \n    /// Get layout usage statistics\n    public func getUsageStatistics() -> LayoutUsageStatistics {\n        let totalLayouts = savedLayouts.count\n        let customLayouts = savedLayouts.filter { $0.isCustom }.count\n        let favoriteLayouts = favoriteLayouts.count\n        let recentLayouts = recentLayouts.count\n        \n        let mostUsedLayout = savedLayouts.max { $0.useCount < $1.useCount }\n        let totalUsage = savedLayouts.reduce(0) { $0 + $1.useCount }\n        \n        return LayoutUsageStatistics(\n            totalLayouts: totalLayouts,\n            customLayouts: customLayouts,\n            favoriteLayouts: favoriteLayouts,\n            recentLayouts: recentLayouts,\n            mostUsedLayout: mostUsedLayout,\n            totalUsage: totalUsage\n        )\n    }\n    \n    // MARK: - Cleanup\n    \n    /// Clean up old layouts\n    public func cleanupOldLayouts() {\n        let cutoffDate = Calendar.current.date(byAdding: .month, value: -3, to: Date()) ?? Date()\n        \n        let oldLayouts = savedLayouts.filter { layout in\n            layout.isCustom &&\n            layout.useCount == 0 &&\n            layout.updatedAt < cutoffDate &&\n            !isFavorite(layout)\n        }\n        \n        for layout in oldLayouts {\n            deleteLayout(layout)\n        }\n    }\n    \n    // MARK: - Private Methods\n    \n    private func setupAutoSave() {\n        autoSaveTimer = Timer.scheduledTimer(withTimeInterval: autoSaveInterval, repeats: true) { [weak self] _ in\n            self?.saveUserPreferences()\n        }\n    }\n    \n    private func updateRecentLayouts() {\n        recentLayouts = userPreferences.recentLayoutIds.compactMap { id in\n            savedLayouts.first { $0.id == id }\n        }\n    }\n    \n    private func updateFavoriteLayouts() {\n        favoriteLayouts = userPreferences.favoriteLayoutIds.compactMap { id in\n            savedLayouts.first { $0.id == id }\n        }\n    }\n    \n    deinit {\n        autoSaveTimer?.invalidate()\n    }\n}\n\n// MARK: - User Layout Preferences\npublic struct UserLayoutPreferences: Codable {\n    public var defaultLayoutId: String?\n    public var recentLayoutIds: [String] = []\n    public var favoriteLayoutIds: [String] = []\n    public var autoSaveEnabled: Bool = true\n    public var syncEnabled: Bool = true\n    public var preferredCategories: [String] = []\n    public var customSettings: [String: String] = [:]\n    \n    public init() {}\n}\n\n// MARK: - Layout Usage Statistics\npublic struct LayoutUsageStatistics {\n    public let totalLayouts: Int\n    public let customLayouts: Int\n    public let favoriteLayouts: Int\n    public let recentLayouts: Int\n    public let mostUsedLayout: Layout?\n    public let totalUsage: Int\n    \n    public var averageUsage: Double {\n        guard totalLayouts > 0 else { return 0 }\n        return Double(totalUsage) / Double(totalLayouts)\n    }\n    \n    public var customLayoutPercentage: Double {\n        guard totalLayouts > 0 else { return 0 }\n        return Double(customLayouts) / Double(totalLayouts) * 100\n    }\n}\n\n// MARK: - Layout Persistence Errors\npublic enum LayoutPersistenceError: Error, LocalizedError {\n    case saveFailed(Error)\n    case loadFailed(Error)\n    case deleteFailed(Error)\n    case updateFailed(Error)\n    case exportFailed(Error)\n    case importFailed(Error)\n    case preferencesError(Error)\n    case unknown(Error)\n    \n    public var errorDescription: String? {\n        switch self {\n        case .saveFailed(let error):\n            return \"Failed to save layout: \\(error.localizedDescription)\"\n        case .loadFailed(let error):\n            return \"Failed to load layouts: \\(error.localizedDescription)\"\n        case .deleteFailed(let error):\n            return \"Failed to delete layout: \\(error.localizedDescription)\"\n        case .updateFailed(let error):\n            return \"Failed to update layout: \\(error.localizedDescription)\"\n        case .exportFailed(let error):\n            return \"Failed to export layout: \\(error.localizedDescription)\"\n        case .importFailed(let error):\n            return \"Failed to import layout: \\(error.localizedDescription)\"\n        case .preferencesError(let error):\n            return \"Failed to save preferences: \\(error.localizedDescription)\"\n        case .unknown(let error):\n            return \"Unknown error: \\(error.localizedDescription)\"\n        }\n    }\n}\n\n// MARK: - Extensions\nextension LayoutPersistenceManager {\n    \n    /// Reset all data\n    public func resetAllData() {\n        // Clear all layouts\n        for layout in savedLayouts {\n            deleteLayout(layout)\n        }\n        \n        // Clear preferences\n        userPreferences = UserLayoutPreferences()\n        saveUserPreferences()\n        \n        // Clear arrays\n        savedLayouts.removeAll()\n        recentLayouts.removeAll()\n        favoriteLayouts.removeAll()\n    }\n    \n    /// Get default layout\n    public func getDefaultLayout() -> Layout? {\n        if let defaultId = userPreferences.defaultLayoutId {\n            return getLayout(by: defaultId)\n        }\n        return savedLayouts.first { $0.isDefault }\n    }\n    \n    /// Set default layout\n    public func setDefaultLayout(_ layout: Layout) {\n        userPreferences.defaultLayoutId = layout.id\n        saveUserPreferences()\n    }\n    \n    /// Get layouts sorted by usage\n    public func getLayoutsSortedByUsage() -> [Layout] {\n        return savedLayouts.sorted { $0.useCount > $1.useCount }\n    }\n    \n    /// Get layouts sorted by date\n    public func getLayoutsSortedByDate() -> [Layout] {\n        return savedLayouts.sorted { $0.updatedAt > $1.updatedAt }\n    }\n    \n    /// Get layouts sorted by name\n    public func getLayoutsSortedByName() -> [Layout] {\n        return savedLayouts.sorted { $0.name < $1.name }\n    }\n}"}